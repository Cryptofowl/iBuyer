{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":16328401594243338985,"abi":{"parameters":[{"name":"CID","type":{"kind":"string","length":59},"visibility":"public"},{"name":"hash","type":{"kind":"string","length":64},"visibility":"public"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3dql3XkYXfRde62LNW/U2/SiOC4zhBYOxgOw1NyLv3kWTJoXXsw/zcI6hg3QROtGuvZdUYVPRleOifr/7y7Z//8bc/vf3+rz/89Oqr//rnq+9++Obrn9/+8P3TT/98tczf/5c//f3r79/9/NPPX//486uv+nr96tvv//Lqq/XIf71+9de333376qu0f715/TQRxxN5PFHHE308sU8nrsfxxDqesOOJ63jieOfX8c6v451fxzu/jnd+He/cj3fuxzv345378c79eOd+vHM/3rkf79yPd+7HO4/jncfxzuN453G88zjeeRzvPI53Hsc7j+Odx/HO83jnebzzPN55Hu88j3eexzvP453n8c7zeOd5vPM63nkd77yOd17HO6/jndfxzut453W88zreeR3vvI933sc77+Od9/HO+3jnfbzzPt55H++8j3fexzvfxzvfxzvfxzvfxzvfxzvfxzvfxzvfxzvfxzvfpzu3x+N4Yh1P2PHEdTzhxxNxPJHHE3U80ccTxztfxztfxztfxztfxztfxztfxztfxztfxztfxztfxzu3453b8c7teOd2vPNjDmfHHM6OOZwdczg75nB2zOHsmMPZMYezYw5nxxzOjjmcHXM4O+Zwdszh7JjD2TGHs2MOZ8cczo45nL3E4VZ/NuHHE3E8kccTdTzRxxP7dOIlDvfMxDqesOOJ453H8c7jeOdxvPM43nkc7zyOd57HO8/jnefxzvN453m88zzeeR7vPI93nsc7z+Od1/HO63jndbzzOt55He+8jndexzuv453X8c7reOd9vPM+3nkf77yPd97HO+/jnffxzvt453288z7e+T7e+T7e+T7e+T7e+T7e+T7e+T7e+T7e+T7e+T7d+fV4HE+s4wk7nnh25+v6NOKfjzy79Ce2/MvIEw3895HXn310V376g8Tj16+/Hh++/lmFPGGzj19v6w99/bNyevrz/cevj8cf+vpntff0P0o/fn3/sa9/VqjLvT/tK+uzhW0w9DxCfGlokSEjQxcZcjIUZCjJUJEhoohFFGFEEUYUYUQRRhRhRBFGFGFEEUYUYUQRRhRxEUVcRBEXUcRFFHERRVxEERdRxEUUcRFFXEQRThThRBFOFOFEEU4U4UQRThThRBFOFOFEEUEUEUQRQRQRRBFBFBFEEUEUEUQRQRQRRBFJFJFEEUkUkUQRSRSRRBFJ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u3vp3b307l56dy+9u5fe3Uvv7qV3t+ndbXp3m97dpne36d1teneb3t2md7fp3W16d196d196d196d196d196d196d196d196d196d196d7ve3a53t+vd7Xp3u97drne3693tene73t2ud3fo3R16d4fe3aF3d+jdHXp3h97doXd36N0denen3t2pd3fq3Z16d6fe3al3d+rdnXp3p97dqXd36d1deneX3t2ld3fp3V16d5fe3aV3d+ndXXp3t97drXd3693dene33t2td3fr3d16d7fe3a1399a7e+vdvfXu3np3b727t97dW+/urXf31rtbn1Vb+qza0mfVlj6rtvRZtSeKqn9E6B+R+keU/hGtf4Te3fqs2tJn1ZY+q7b0WbWlz6otfVZt6bNqS59VW/qs2tJn1ZY+q7b0WbWlz6otfVZt6bNqS59VW/qs2tJn1ZY+q7b0WbWlz6otfVZt6bNqS59VW/qs2tJn1ZY+q7b0WbWlz6otfVZt6bNqS59VW/qs2tJn1ZY+q7b0WbWlz6otfVZt6bNqS59VW/qs2tJn1ZY+q7b0WbWlz6otfVZt6bNqS59VW/qs2tJn1ZY+q7b0WbWlz6otfVZt6bNqS59VW/qs2tJn1ZY+q7b0WbWlz6otfVZt6bNqS59VW/qs2tJn1ZY+q7b0WbWlz6otfVZt6bNqS59VW/qs2tJn1ZY+q7b0WbWlz6otfVZt6bNqS59VW/qs2tJn1ZY+q7b0WbWlz6otfVZt6bNqS59VW/qs2tJn1UyfVTN9Vs30WTXTZ9Xs4fpHhP4RqX9E6R/R+kfo3a3Pqpk+q2b6rJrps2qmz6qZPqtm+qya6bNqps+qmT6rZvqsmumzaqbPqpk+q2b6rJrps2qmz6qZPqtm+qya6bNqps+qmT6rZvqsmumzaqbPqpk+q2b6rJrps2qmz6qZPqtm+qya6bNqps+qmT6rZvqsmumzaqbPqpk+q2b6rJrps2qmz6qZPqtm+qya6bNqps+qmT6rZvqsmumzaqbPqpk+q2b6rJrps2qmz6qZPqtm+qya6bNqps+qmT6rZvqsmumzaqbPqpk+q2b6rJrps2qmz6qZPqtm+qya6bNqps+qmT6rZvqsmumzaqbPqpk+q2b6rJrps2qmz6qZPqtm+qya6bNqps+qmT6rZvqsmumzaqbPqpk+q2b6rJrps2qmz6qZPqt26bNqlz6rdumzapc+q3Y9XP+I0D8i9Y8o/SNa/wi9u/VZtUufVbv0WbVLn1W79Fm1S59Vu/RZtUufVbv0WbVLn1W79Fm1S59Vu/RZtev5rJo9wj89Iv33H/HuX3/45cPvstKfPnw99zqP3J++uOuFd/drffywu33+7j743WPwu+fgd68v+N3j13cP78/fvQe/+5777s9HI4e8+xr87jb43Qff1WvwXb0G39Vr8F29Bt/V60u+qy/9vn/Jd/WFd/cv+a6+9O5f8l196d0H31UffFd98F31wXfVB99VH3xXffBd9cF3NQbf1Rh8V2PwXY3BdzUG39UYfFdj8F2NwXc1Bt/VGHxXc/BdzcF3NQff1Rx8V3PwXc3BdzUH39UcfFdz8F3NwXe1Bt/VGnxXa/BdrcF3tQbf1Rp8V2vwXa3Bd7UG39UafFd78F3twXe1B9/VHnxXe/Bd7cF3tQff1R58V3vwXe3Bd3UPvqt78F3dg+/qHnxX9+C7ugff1T34ru7Bd3UPvqt77l31x9y76o+5d9Ufc++qP+beVX/Mvav+mHtX/TH3rvpj7l31x9y76o/Bd3UNvqtr8F1dg+/qGnxX1+C7ugbf1TX4rq7Bd3UNvqtr8F21wXfVBt9VG3xXB/ct+eC+JR/ct+SD+5Z8cN+Sf9F9Sy/9vg++q19039JL7z74rg7uW/LBfUs+uG/JB/ct+eC+JR/ct+SD+5Z8cN+SD+5b8sF9Sz64b8kH9y354L4lH9y35IP7lnxw35IP7lvywX1LPrhvyQf3LfngviUf3Lfkg/uWfHDfkg/uW/LBfUs+uG/JB/ct+eC+JR/ct+SD+5Z8cN+SD+5b8sF9Sz64b8kH9y354L4lH9y35IP7lnxw35IP7lvywX1LPrhvyQf3LfngviUf3Lfkg/uWfHDfkg/uW/LBfUs+uG/JB/ct+eC+JR/ct+SD+5Z8cN+SD+5b8sF9Sz64b8kH9y354L4lH9y35IP7lnxw35IP7lvywX1LPrhvyQf3LcXgvqUY3LcUg/uWYnDfUjzm3tUY3LcUg/uWYnDfUgzuW4rBfUsxuG8pBvctxeC+pRjctxSD+5ZicN9SDO5bisF9SzG4bykG9y3F4L6lGNy3FIP7lmJw31IM7luKwX1LMbhvKQb3LcXgvqUY3LcUg/uWYnDfUgzuW4rBfUsxuG8pBvctxeC+pRjctxSD+5ZicN9SDO5bisF9SzG4bykG9y3F4L6lGNy3FIP7lmJw31IM7luKwX1LMbhvKQb3LcXgvqUY3LcUg/uWYnDfUgzuW4rBfUsxuG8pBvctxeC+pRjctxSD+5ZicN9SDO5bisF9SzG4bykG9y3F4L6lGNy3FIP7lmJw31IM7luKwX1LMbhvKQb3LcXgvqUY3LcUg/uWYnDfUgzuW4rBfUsxuG8pBvctxeC+pRjctxSD+5ZicN9SDO5bisF9SzG4bykG9y3F4L6lGNy3FIP7lmJw31IM7luKwX1LMbhvKQb3LeXgvqUc3LeUg/uWcnDfUj7m3tUc3LeUg/uWcnDfUg7uW8rBfUs5uG8pB/ct5eC+pRzct5SD+5ZycN9SDu5bysF9Szm4bykH9y3l4L6lHNy3lIP7lnJw31IO7lvKwX1LObhvKQf3LeXgvqUc3LeUg/uWcnDfUg7uW8rBfUs5uG8pB/ct5eC+pRzct5SD+5ZycN9SDu5bysF9Szm4bykH9y3l4L6lHNy3lIP7lnJw31L+Rt/SenyaWpafT20y9RsdQy9NLTRlaOpCU46mAk0lmio0hbQRSBuJtJFIG4m0kUgbibSRSBuJtJFIG4m0kUgbhbRRSBuFtFFIG4W0UUgbhbRRSBuFtFFIG4200UgbjbTRSBuNtNFIG4200UgbjbTRSBsbaWMjbWykjY20sZE2NtLGRtrYSBsbaWMTbdTjgaYWmjI0daEpR1OBphJNFZpqNIW0sZA21rE2nn74849vv/vu7d/+9N0P33z989sfvv/p3ejj3X88b9dd+fGPiY/Hr3+aux7v3uF5r/7+SJ2P9PnIPh5Zzxv0hZkFZgzMXGDGwUyAmQQzBWYazAAdLKCDBXSwgA4W0MECOlhABwvoYAEdLKCDBXRgQAcGdGBABwZ0YEAHBnRgQAcGdGBABwZ0cAEdXEAHF9DBBXRwAR1cQAcX0MEFdHABHVxABw504EAHDnTgQAcOdOBABw504EAHDnTgQAcBdBBABwF0EEAHAXQQQAcBdBBABwF0EEAHCXSQQAcJdJBABwl0kEAHCXSQQAcJdJBABwV0UEAHBXRQQAcFdFBAB8//HwRt/ctM5/pspM5H+nxkn408/bDeffAmCDdBuAnCTRBugnAThJsg3AThJgg3QbgJwk0QboJwE4SbIPzHCMILM0AHBXRQQAcNdPB8sPB3+cbzqcLfH7nOR/yYoti7D94xlBsi3RDphkhvboh0Q6QbIt0Q6YZIN0S6IdINkW6IdEOkGyLdEOmGSP8hiPTCDNBBAx000EEDHTTQQQMdNNBBAx1soIMNdLCBDjbQwQY6ACxxAZi4AE1cACcuwBMN8EQDPNEATzTAEw3wRAM80QBPNMATDfBEAzzRAE80wBMN8EQDPNEATzTAEw3wRAM80QBPNMATDfBEAzzRAE80wBMN8EQDPNEATzTAEw3wRAM80QBPNMATDfBEAzzRAE80wBMN8EQDPNEATzTAEw3wRAM80QBPNMATDfBEAzzRAE80wBMN8EQDPNEATzTAEw3wRAM80QBPNMATDfBEAzzRAE80wBMN8EQDPNEATzTAEw3wRAM80QBPNMATLY//hSbLfTzyPE38/ZHDJNLTD9e7D6478XInXt7ciZcPM3fi5U683ImX9zN34uVOvLy5Ey8fZu7Ey514uRMv72fuxMudeHlzJ14+zNyJlzvxcide3s/ciZc78fLmTrx8mLkTL3fi5U68vJ+5Ey934uXNnXj5MHMnXu7Ey514eT9zJ17uxMubO/HyYWZc4uWFGaADwBMN8EQDPNHquIDHnseJvz8S5yOHLc7/evrpv7/+8e3Xf/7u25+eJt794j++/+bjX0X19OPP//P3j7/y8S+r+vuPP3zz7V/+8eO37/7aql//xqp3vyd9vd7Xm3eJk6cfnrDe6yes9amR+f0H+vXuXz+Qr5+Yz6eyoc++4ek3+rVVfwonffYNT7/42vp6+ud4+mf5Xw==","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            /*@safety: `sorted` array is checked to be:\n                a. a permutation of `input`'s elements\n                b. satisfying the predicate `ordering`\n            */\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"62":{"source":"fn main(CID: pub str<59>, hash: pub str<64>) {\n    let mut (multibase, CIDbytes) = CID.as_bytes().as_slice().pop_front();\n    assert(multibase == 66); // Assert that the base is base32\n\n    println(CID);\n    println(hash);\n    println(CID.as_bytes());\n    println(hash.as_bytes());\n\n    // Map ASCII symbols to base32 encodings\n    let mut base32: [[u1;5];96] = [[0,0,0,0,0];96];\n\n    base32[65] = [0,0,0,0,0];\n    base32[66] = [0,0,0,0,1];\n    base32[67] = [0,0,0,1,0];\n    base32[68] = [0,0,0,1,1];\n    base32[69] = [0,0,1,0,0];\n    base32[70] = [0,0,1,0,1];\n    base32[71] = [0,0,1,1,0];\n    base32[72] = [0,0,1,1,1];\n    base32[73] = [0,1,0,0,0];\n    base32[74] = [0,1,0,0,1];\n    base32[75] = [0,1,0,1,0];\n    base32[76] = [0,1,0,1,1];\n    base32[77] = [0,1,1,0,0];\n    base32[78] = [0,1,1,0,1];\n    base32[79] = [0,1,1,1,0];\n    base32[80] = [0,1,1,1,1];\n    base32[81] = [1,0,0,0,0];\n    base32[82] = [1,0,0,0,1];\n    base32[83] = [1,0,0,1,0];\n    base32[84] = [1,0,0,1,1];\n    base32[85] = [1,0,1,0,0];\n    base32[86] = [1,0,1,0,1];\n    base32[87] = [1,0,1,1,0];\n    base32[88] = [1,0,1,1,1];\n    base32[89] = [1,1,0,0,0];\n    base32[90] = [1,1,0,0,1];\n    base32[50] = [1,1,0,1,0];\n    base32[51] = [1,1,0,1,1];\n    base32[52] = [1,1,1,0,0];\n    base32[53] = [1,1,1,0,1];\n    base32[54] = [1,1,1,1,0];\n    base32[55] = [1,1,1,1,1];\n\n    // Decode CID\n    let mut buffer: [u1;290] = [0;290]; \n    for i in 0..58 {\n        buffer[i*5]     = base32[CIDbytes[i]][0];\n        buffer[i*5+1]   = base32[CIDbytes[i]][1];\n        buffer[i*5+2]   = base32[CIDbytes[i]][2];\n        buffer[i*5+3]   = base32[CIDbytes[i]][3];\n        buffer[i*5+4]   = base32[CIDbytes[i]][4];\n    }\n\n    // Needs to be in nibbles for hex encoding\n    // Ignore first 4 bytes for version, multicodec, multihash, and length\n    let mut result: [u8;64] = [0;64];\n    for i in 8..buffer.len() / 4 {\n        let nibble: [u1;4] = [buffer[i*4], buffer[i*4+1], buffer[i*4+2], buffer[i*4+3]];\n        result[i-8] = binary_to_4bit_integer(nibble);\n    }\n\n    let mut digest: [u8;64] = result.map(|r| four_bit_to_hex(r));\n    assert(digest == hash.as_bytes()); // Assert that the decoded hash is equal to input hash\n\n}\n\nfn binary_to_4bit_integer(nibble: [u1; 4]) -> u8 {\n    let mut result: u8 = 0;\n    for i in 0..4 {\n        result += (nibble[i] as u8) * ((2).pow_32(3 - i as Field)) as u8;\n    }\n    result\n}\n\nfn four_bit_to_hex(nibble: u8) -> u8 {\n    assert(nibble < 16); // Ensure it's a 4-bit integer\n    let hex_chars = \"0123456789ABCDEF\".as_bytes();\n    hex_chars[nibble]\n}\n","path":"/home/chicken/Work/decoder/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained","directive_integer_quotient"]}